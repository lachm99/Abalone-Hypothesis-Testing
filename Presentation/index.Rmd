---
title: "An Abalone-Age Investigation"
subtitle: "Group Project 1"
author: "M09B Early 5"
date: "November 20"
output:
  xaringan::moon_reader:
    css: ["default", "assets/sydney-fonts.css", "assets/sydney.css"]
    self_contained: false # if true, fonts will be stored locally
    seal: false # show a title slide with YAML information
    includes:
      in_header: "assets/mathjax-equation-numbers.html"
    nature:
      beforeInit: ["assets/remark-zoom.js", "https://platform.twitter.com/widgets.js"]
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      ratio: '16:9' # alternatives '16:9' or '4:3' or others e.g. 13:9
      navigation:
        scroll: false # disable slide transitions by scrolling
---
class: title-slide

.pull-left[
# Abalone Age

## Group Project

### M09B Early 5

### November 2020]

.pull-right[<image src="https://pelledolce.com/wp-content/uploads/abalones.jpg">]

---
exclude: true
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=FALSE, message=FALSE)
# install.packages("qtlcharts")
# install.packages("corrplot")
# install.packages("GGally")
# install.packages("ggfortify")
# install.packages("caret")
# install.packages("sjPlot")
library(tidyverse)
library(qtlcharts)
library(corrplot)
library(GGally)
library(ggfortify)
library(caret)
library(sjPlot)

cols = c("sex",	
             "length",
             "diam",
             "height",
             "weight_whole",
             "weight_shucked",
             "weight_viscera",
             "weight_shell",
             "rings")

raw_data = readr::read_csv("../Data/abalone.data", cols)

data = raw_data %>% mutate(sex = factor(sex, c("M", "F", "I")),
                       rings = as.integer(rings)) %>%
filter(height < 0.5)


```

---
## Data Description - Abalone
- Dataset concerning .brand-red[marine snails], via Marine Research Laboratories, Taroona.


```{r, echo=FALSE}
desc_table = data.frame(colnames = c("Variable Name",
                                     "Variable Type",
                                     "Description"))

variable_names = c("Sex",
                   "Length",
                   "Diameter",
                   "Height",
                   "Whole Weight",
                   "Shucked Weight",
                   "Viscera Weight",
                   "Shell Weight",
                   "Rings")
variable_types = c("Factor",
                   "Continuous",
                   "Continuous",
                   "Continuous",
                   "Continuous",
                   "Continuous",
                   "Continuous",
                   "Continuous",
                   "Integer")
variable_descs = c("Adult, Female, or Infant (Unidentified)",
                   "Longest shell measurement",
                   "Perpendicular to length",
                   "With meat in shell",
                   "Grams	whole abalone",
                   "Grams	weight of meat",
                   "Grams	gut weight (after bleeding)",
                   "Grams	after being dried",
                   "Number of Rings. +1.5 gives age in years")

desc_table = data.frame(variable_names, variable_types, variable_descs)

colnames(desc_table) = c("Variable Name",
                         "Variable Type",
                         "Description")
knitr::kable(desc_table)

```
<!-- - Construct a model to predict .brand-red[abalone age] without exhaustive ring counting. -->

* Question: investigate whether we can predict the number of rings/age of the abalone with all the provided variables

---
## Initial Inspection and Transformations
```{r, echo=FALSE}
res = model.matrix(~sex, data)

numericised_sex = select(data, -sex)
numericised_sex$sex_f = res[,2]
numericised_sex$sex_i = res[,3]

transformed = numericised_sex %>% mutate(log_whole = log(weight_whole),
                log_shucked = log(weight_shucked),
                log_viscera = log(weight_viscera),
                log_shell = log(weight_shell),
                log_diam = log(diam),
                log_length = log(length),
                sqrt_height = sqrt(height),
                sqrt_log_rings = sqrt(log(rings))) %>%
              select(log_whole,
                log_shucked,
                log_viscera,
                log_shell,
                log_diam,
                log_length,
                sqrt_height,
                sex_f,
                sex_i,
                sqrt_log_rings)
```

.pull-left[
### Initial
```{r}
qtlcharts::iplotCorr(select(data,-sex))
```

.small[.brand-red[Excluding `Sex` factor.]]

]

.pull-right[
### Transformed
```{r}
qtlcharts::iplotCorr(transformed)
```

.small[.brand-red[Including `Sex`; utilising dummy-coding to construct a contrast matrix.]]
]
---

.pull-left[## .brand-red[Initial, excluding `sex`].
```{r}
fn_data = function(data, mapping, ...) {
  p = ggplot(data = data, mapping = mapping) +
    geom_point(shape=".") +
    geom_smooth(method=lm, fill = "green", color="green", se = FALSE)  +
    geom_smooth(method=loess, fill = "red", color="red", se = FALSE)
  p
}
GGally::ggpairs(data, columns = 1:9, lower = list(continuous = fn_data)) + theme_bw(base_size = 10)
```
]

.pull-right[## .brand-red[Transformed, including `sex`].
```{r, warning = FALSE}
fn_data = function(data, mapping, ...) {
  p = ggplot(data = transformed, mapping = mapping) +
    geom_point(shape=".") +
    geom_smooth(method=lm, fill = "green", color="green", se = FALSE) +
    geom_smooth(method=loess, fill = "red", color="red", se = FALSE)
  p
}
GGally::ggpairs(transformed, columns = 1:10, lower = list(continuous = fn_data)) + theme_bw(base_size = 10)
```

]
---

```{r}
M1 = lm(sqrt_log_rings ~ ., transformed)
# M1
# drop1(M1, test = "F")

step.back.aic = step(M1, direction = "backward", trace = FALSE)
# summary(step.back.aic)

M2 = lm(sqrt_log_rings ~ 1, transformed)

step.fwd.aic = step(M2, scope=list(lower=M2, upper=M1),                    direction = "forward",                    trace = FALSE)

# summary(step.fwd.aic)
```


## Model Selection

```{r}
# sjPlot::tab_model(step.fwd.aic, show.ci = FALSE,show.aic = TRUE,dv.labels = c("Forward model"))

sjPlot::tab_model(step.fwd.aic, step.back.aic, show.ci = FALSE,show.aic = TRUE,dv.labels = c("Forward model","Backward model"))
```



---

## Assumption Checking

.pull-left[## .brand-red[ Residual vs Fitted].
```{r, warning = FALSE}
# autoplot(step.fwd.aic,which=1)
x = transformed
x = x %>% mutate(lfitted = step.fwd.aic$fitted.values, lresid = step.fwd.aic$residuals )
ggplot(x, aes(x = lfitted ,y = lresid)) + geom_point(size = 1) +geom_smooth()
```
]

.pull-right[## .brand-red[QQ plot].
```{r, warning = FALSE}
# autoplot(step.fwd.aic,which=2)
qqnorm(step.fwd.aic$residuals)
qqline(step.fwd.aic$residuals)
```
]
---

## Comparing RMSE and MAE


```{r}
tr_red = transformed
set.seed(1)
fold_id= c(1:5, rep(1:10, each=417))
tr_red$fold_id = sample(fold_id, replace = FALSE)


k = 10
forward_mse = forward_mae = vector(mode = "numeric", length = k)
back_mse = back_mae = vector(mode = "numeric", length = k)

for (i in 1:k) {
    test_set = tr_red[fold_id == i,]
    training_set = tr_red[fold_id != i,]
    M3 = lm(sqrt_log_rings ~ ., training_set)
    back = step(M3, direction = "backward", trace = FALSE)
    M4 = lm(sqrt_log_rings ~ 1, training_set)
    forward = step(M4, scope=list(lower=M4, upper=M3),direction = "forward",trace = FALSE)
    back_pred = predict(back, test_set)
    forward_pred = predict(forward, test_set)
    back_mse[i] = mean((test_set$sqrt_log_rings - back_pred)^2)
    back_mae[i] = mean(abs(test_set$sqrt_log_rings - back_pred))
    forward_mse[i] = mean((test_set$sqrt_log_rings - forward_pred)^2)
    forward_mae[i] = mean(abs(test_set$sqrt_log_rings - forward_pred))
}
```


```{r}
forward_res = tibble(forward_mse, forward_mae)
back_res = tibble(back_mse, back_mae)
c(sqrt(mean(forward_mse)), sqrt(mean(back_mse)))
```

<!-- Backward model has smaller rmes value -->

```{r}
c(mean(forward_mae), mean(back_mae))
```


```{r}
# back_res %>% gather(key = "metric", value = "error") %>% 
#   separate(col = metric, into = c("model", "metric")) %>%
#   ggplot(aes(x = model, y = error)) + facet_wrap(~metric, scales = "free_y") +
#   geom_boxplot()
# 
# forward_res %>% gather(key = "metric", value = "error") %>% 
#   separate(col = metric, into = c("model", "metric")) %>%
#   ggplot(aes(x = model, y = error)) + facet_wrap(~metric, scales = "free_y") +
#   geom_boxplot()
```


```{r, warning = FALSE}
cv_forward= train(
    sqrt_log_rings ~ . - log_diam - log_length - sex_f,
    transformed,
    method = "lm",
    trtControl = trainControl(
        method = "cv", number = 10,
        verboseIter = FALSE
    )
)

# cv_forward
```

```{r, warning = FALSE}
cv_back= train(
    sqrt_log_rings ~ . -sex_f,
    transformed,
    method = "lm",
    trtControl = trainControl(
        method = "cv", number = 10,
        verboseIter = FALSE
    )
)

# cv_back
```

.pull-left[## .brand-red[RMSE].
```{r}
results = resamples(list(forward = cv_forward,
                         back = cv_back))
ggplot(results, metric = "RMSE") + labs(y = "RMSE")
```
]

.pull-right[## .brand-red[MAE].
```{r}
ggplot(results, metric = "MAE") + labs(y = "MAE")
```
]

---

## Final model

```{r}
sjPlot::tab_model(step.back.aic, show.ci = FALSE,show.aic = TRUE,dv.labels = c("Final model"))
```

$\widehat{\sqrt{log(rings)}} = 1.43 + 0.11 log(shell) - 0.19 log(shucked) + 0.19 log(whole) - 0.03 log(viscera)$ 
$$- 0.13 \sqrt{height} - 0.02 Sex_{infant}$$

```{r, load_refs, warning = FALSE, echo=FALSE, cache=FALSE}
library(bibtex)
library(RefManageR)
BibOptions(check.entries = FALSE,
           bib.style = "authoryear",
           cite.style = 'authoryear',
           style = "markdown",
           hyperlink = FALSE,
           dashed = FALSE)
myBib <- ReadBib("assets/example.bib", check = FALSE)
```


